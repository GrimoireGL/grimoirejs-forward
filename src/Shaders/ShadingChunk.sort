@ReferMacro(DIR_LIGHT_COUNT,0)
@ReferMacro(POINT_LIGHT_COUNT,0)
@ReferMacro(SPOT_LIGHT_COUNT,0)
@ReferMacro(SHADOW_MAP_COUNT,0)
@ReferMacro(OES_TEXTURE_FLOAT,)

#if DIR_LIGHT_COUNT > 0
  #define USE_DIR_LIGHT
#endif

#if POINT_LIGHT_COUNT > 0
  #define USE_POINT_LIGHT
#endif

#if SPOT_LIGHT_COUNT > 0
  #define USE_SPOT_LIGHT
#endif

#if SHADOW_MAP_COUNT > 0
  #define USE_SHADOW_MAP
#endif

#ifdef USE_DIR_LIGHT
  @DIRECTIONAL_LIGHT_DIRECTIONS
  uniform vec3 _dLightDir[DIR_LIGHT_COUNT];

  @DIRECTIONAL_LIGHT_COLORS
  uniform vec3 _dLightColor[DIR_LIGHT_COUNT];

  @DIRECTIONAL_LIGHT_PARAMS
  uniform vec4 _dLightParams[DIR_LIGHT_COUNT];
#endif

#ifdef USE_POINT_LIGHT

  @POINT_LIGHT_POSITIONS
  uniform vec3 _pLightPosition[POINT_LIGHT_COUNT];

  @POINT_LIGHT_COLORS
  uniform vec3 _pLightColor[POINT_LIGHT_COUNT];

  @POINT_LIGHT_PARAMS
  uniform vec2 _pLightParam[POINT_LIGHT_COUNT];

#endif

#ifdef USE_SPOT_LIGHT

  @SPOT_LIGHT_POSITIONS
  uniform vec3 _sLightPosition[POINT_LIGHT_COUNT];

  @SPOT_LIGHT_DIRECTIONS
  uniform vec3 _sLightDir[POINT_LIGHT_COUNT];

  @SPOT_LIGHT_COLORS
  uniform vec3 _sLightColor[POINT_LIGHT_COUNT];

  @SPOT_LIGHT_PARAMS
  uniform vec3 _sLightParam[POINT_LIGHT_COUNT];
#endif

#ifdef USE_SHADOW_MAP
  @SHADOW_MAP_ELEMENT_SIZE
  uniform float _shadowmapElementSize;

  @SHADOW_MAP_PIXEL_SIZE
  uniform float _shadowMapPixelSize;

  @SHADOW_MAP_X_COUNT
  uniform int _shadowMapXCount;

  @SHADOW_MATRICES
  uniform sampler2D _lightMatrices;

  @SHADOW_MATRICES_COUNT
  uniform float _lightMatricesCount;

  @SHADOW_MAP_TEXTURE
  uniform sampler2D _shadowMapTexture;

  @{default:0.01}
  uniform float shadowBias;

  highp float decodeFloatRGB( vec3 rgb ) {
    return dot( rgb, vec3(1.0, 1./255.0, 1./65025.0) );
  }
#endif

  float lambert(vec3 lightDirection,vec3 surfaceNormal) {
    return max(0.0, dot(lightDirection, surfaceNormal));
  }

  #ifndef DIFFUSE_BRDF
    #define DIFFUSE_BRDF lambertBRDF

    vec3 lambertBRDF(vec3 c,vec3 i,vec3 o,vec3 n,float roughness){
      return c / PI;
    }
  #endif

  #ifndef SPECULAR_BRDF
    #define SPECULAR_BRDF cookTorranceBRDF

    #ifndef CT_D
      #define CT_D ctd_GGX_Distribution
    #endif

    #ifndef CT_F
      #define CT_F ctf_Schlick
    #endif

    #ifndef CT_G
      #define CT_G ctg_GGX_GeometryTerm
    #endif

    float ctd_GGX_Distribution(vec3 l,vec3 v,vec3 n,vec3 h,float roughness){
      float alpha2 = pow(roughness,4.0);
      float nh2 = pow(dot(n,h),2.0);
      return alpha2/(PI*pow(nh2*(alpha2 - 1.0) + 1.0,2.0));
    }

    float ctg_GGX_GeometryTerm(vec3 l,vec3 v,vec3 n,vec3 h,float roughness){
      float k = pow(roughness + 1.0,2.0)/8.0;
      float ln = dot(l,n);
      float vn = dot(v,n);
      return (ln/(ln*(1.-k) + k))*(vn/(vn*(1.-k) + k));
    }

    float ctf_Schlick(vec3 l,vec3 v,vec3 n,vec3 h,float roughness){
      float f0 = refractive;
      float vh = dot(v,h);
      return f0 + pow(1.0-vh,5.0) * (1.0 - f0);
    }

    vec3 cookTorranceBRDF(vec3 l,vec3 v,vec3 n,float r){
      vec3 h = normalize(l+v);
      return vec3(CT_D(l,v,n,h,r) * CT_F(l,v,n,h,r) * CT_G(l,v,n,h,r)/(4.0 * dot(l,n) * dot(v,n)));
    }
  #endif

  #ifndef PBR_BRDF
    #define PBR_BRDF pbrBRDF
    vec3 pbrBRDF(vec3 c,vec3 i,vec3 o,vec3 n,float r){
      float k0 = kCoeff;
      return DIFFUSE_BRDF(c,i,o,n,r) * k0 + SPECULAR_BRDF(i,o,n,r) * (1.0 - k0);
    }
  #endif
#ifdef USE_DIR_LIGHT

#ifdef USE_SHADOW_MAP

uniform float smT;
  bool isUVRegion(vec2 uv){
    return all(bvec4(greaterThanEqual(uv,vec2(0,0)),lessThanEqual(uv,vec2(1,1))));
  }

  float shadowCoefficient(vec3 fragPosition,highp mat4 lightMatrix){
    highp vec4 lPos = lightMatrix * vec4(fragPosition,1.0);
    if(any(bvec2(lPos.z/lPos.w > 1.0,lPos.z/lPos.w < -1.0))){
      return 1.;
    }
    vec2 bUV = lPos.xy / lPos.w / 2.0 + vec2(0.5);
    highp float od = (lPos.z/lPos.w + 1.0)/2.0;
    float fill = 0.0;
    float N = 0.00001;
    // PCF sampling
    if(isUVRegion(bUV)){
      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,bUV).rgb);
      fill += 2. * step(shadowBias,od-d);
      N+=2.0;
    }
    vec2 lUV = bUV + vec2(_shadowMapPixelSize,0);
    if(isUVRegion(lUV)){
      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,lUV).rgb);
      fill += step(shadowBias,od-d);
      N++;
    }
    lUV = bUV + vec2(-_shadowMapPixelSize,0);
    if(isUVRegion(lUV)){
      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,lUV).rgb);
      fill += step(shadowBias,od-d);
      N++;
    }
    lUV = bUV + vec2(0,_shadowMapPixelSize);
    if(isUVRegion(lUV)){
      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,lUV).rgb);
      fill += step(shadowBias,od-d);
      N++;
    }
    lUV = bUV + vec2(0,-_shadowMapPixelSize);
    if(isUVRegion(lUV)){
      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,lUV).rgb);
      fill += step(shadowBias,od-d);
      N++;
    }
    return max(0.0,1.0 - fill/N);
  }

  highp vec4 fromLightMatrices(vec2 uv){
    return texture2D(_lightMatrices,uv);
  }

  highp mat4 fetchLightMatrix(float index){
    float y = 1.0 / _lightMatricesCount * (index  + 0.5);
    return mat4(
      fromLightMatrices(vec2(0.125,y)),
      fromLightMatrices(vec2(0.375,y)),
      fromLightMatrices(vec2(0.625,y)),
      fromLightMatrices(vec2(0.875,y))
      );
  }
#endif

  vec3 directionalLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){
    vec3 result = vec3(0,0,0);
    for(int i = 0; i < DIR_LIGHT_COUNT;i++){
      vec3 lI = lambert(fragNormal,-_dLightDir[i]) * _dLightColor[i];
      float sc = 1.0;
      #ifdef USE_SHADOW_MAP // Shadowmap Calculations
        if(_dLightParams[i].x >= 0.0){
          highp mat4 lMat = fetchLightMatrix(_dLightParams[i].x);
          sc = shadowCoefficient(fragPosition,lMat);
          highp vec4 lPos = lMat * vec4(fragPosition,1.0);
        }
      #endif
      vec3 lColor = sc * lI * PBR_BRDF(baseColor,-_dLightDir[i],normalize(_cameraPosition - fragPosition),fragNormal,roughness);
      result += lColor;
    }
    return result;
  }
#endif
#ifdef USE_POINT_LIGHT
  vec3 pointLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){
    vec3 result = vec3(0,0,0);
    for(int i = 0; i < POINT_LIGHT_COUNT;i++){
      vec3 l2p = _pLightPosition[i] - fragPosition;
      float d = length(l2p);
      vec2 param = _pLightParam[i];
      float atten = max(0.,1.0-d/param.x)/(1.0 + param.y*param.y*d);
      l2p = normalize(l2p);
      vec3 lI = lambert(fragNormal,l2p)* _pLightColor[i] * atten;
      vec3 lColor = lI  * PBR_BRDF(baseColor,l2p,normalize(_cameraPosition - fragPosition),fragNormal,roughness);
      result += lColor ;
    }
    return result;
  }
#endif
#ifdef USE_SPOT_LIGHT
  vec3 spotLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){
    vec3 result = vec3(0);
    for(int i = 0; i < SPOT_LIGHT_COUNT; i++){
      float innerConeAngle = _sLightParam[i].x;
      float outerConeAngle = _sLightParam[i].y;
      float outCos=cos(outerConeAngle);
      float innCos=cos(innerConeAngle);

      vec3 p2l = _sLightPosition[i] - fragPosition;
      float d = length(p2l);
      p2l=p2l/d;
      float c = dot(-p2l,normalize(_sLightDir[i]));
      float decay = _sLightParam[i].z;//減衰係数
      decay = 1.;
      float angleDecay = decay;
      //
      float distDecayCoefficient = 1.0 / (d * d);
      float angleDecayCoefficient = pow(clamp((c-outCos)/(innCos-outCos),0.0,1.0),angleDecay);
      //
      vec3 lI = lambert(p2l,fragNormal)*_sLightColor[i]*angleDecayCoefficient*distDecayCoefficient;
      vec3 lColor = lI * PBR_BRDF(baseColor,p2l,normalize(_cameraPosition - fragPosition),fragNormal,roughness);
      result += lColor;
    }
    return result;
  }
#endif
  vec3 shading(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){
    vec3 lightingColor = vec3(0);
    #ifdef USE_DIR_LIGHT
    lightingColor.rgb += directionalLight(baseColor,fragNormal,fragPosition,roughness);
    #endif
    #ifdef USE_POINT_LIGHT
    lightingColor.rgb += pointLight(baseColor,fragNormal,fragPosition,roughness);
    #endif
    #ifdef USE_SPOT_LIGHT
    lightingColor.rgb += spotLight(baseColor,fragNormal,fragPosition,roughness);
    #endif
    return lightingColor;
  }
