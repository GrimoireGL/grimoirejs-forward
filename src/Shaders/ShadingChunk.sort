@ReferMacro(DIR_LIGHT_COUNT,0)
@ReferMacro(POINT_LIGHT_COUNT,0)
@ReferMacro(SPOT_LIGHT_COUNT,0)

#if DIR_LIGHT_COUNT > 0
  #define USE_DIR_LIGHT
#endif

#if POINT_LIGHT_COUNT > 0
  #define USE_POINT_LIGHT
#endif

#if SPOT_LIGHT_COUNT > 0
  #define USE_SPOT_LIGHT
#endif

#ifdef USE_DIR_LIGHT

  @DIRECTIONAL_LIGHT_DIRECTIONS
  uniform vec3 _dLightDir[DIR_LIGHT_COUNT];

  @DIRECTIONAL_LIGHT_COLORS
  uniform vec3 _dLightColor[DIR_LIGHT_COUNT];

#endif

#ifdef USE_POINT_LIGHT

  @POINT_LIGHT_POSITIONS
  uniform vec3 _pLightPosition[POINT_LIGHT_COUNT];

  @POINT_LIGHT_COLORS
  uniform vec3 _pLightColor[POINT_LIGHT_COUNT];

  @POINT_LIGHT_PARAMS
  uniform vec2 _pLightParam[POINT_LIGHT_COUNT];

#endif

#ifdef USE_SPOT_LIGHT

  @SPOT_LIGHT_POSITIONS
  uniform vec3 _sLightPosition[POINT_LIGHT_COUNT];

  @SPOT_LIGHT_DIRECTIONS
  uniform vec3 _sLightDir[POINT_LIGHT_COUNT];

  @SPOT_LIGHT_COLORS
  uniform vec3 _sLightColor[POINT_LIGHT_COUNT];

  @SPOT_LIGHT_PARAMS
  uniform vec3 _sLightParam[POINT_LIGHT_COUNT];
#endif

  float lambert(vec3 lightDirection,vec3 surfaceNormal) {
    return max(0.0, dot(lightDirection, surfaceNormal));
  }

  #ifndef DIFFUSE_BRDF
    #define DIFFUSE_BRDF lambertBRDF

    vec3 lambertBRDF(vec3 c,vec3 i,vec3 o,vec3 n){
      return c / PI;
    }
  #endif

  #ifndef SPECULAR_BRDF
    #define SPECULAR_BRDF(i,o,n) cookTorranceBRDF(i,o,n)

    #ifndef CT_D
      #define CT_D ctd_GGX_Distribution
    #endif

    #ifndef CT_F
      #define CT_F ctf_Schlick
    #endif

    #ifndef CT_G
      #define CT_G ctg_GGX_GeometryTerm
    #endif

    float ctd_GGX_Distribution(vec3 l,vec3 v,vec3 n,vec3 h){
      float alpha2 = pow(roughness,4.0);
      float nh2 = pow(dot(n,h),2.0);
      return alpha2/(PI*pow(nh2*(alpha2 - 1.0) + 1.0,2.0));
    }

    float ctg_GGX_GeometryTerm(vec3 l,vec3 v,vec3 n,vec3 h){
      float k = pow(roughness + 1.0,2.0)/8.0;
      float ln = dot(l,n);
      float vn = dot(v,n);
      return (ln/(ln*(1.-k) + k))*(vn/(vn*(1.-k) + k));
    }

    float ctf_Schlick(vec3 l,vec3 v,vec3 n,vec3 h){
      float f0 = refractive;
      float vh = dot(v,h);
      return f0 + pow(1.0-vh,5.0) * (1.0 - f0);
    }

    vec3 cookTorranceBRDF(vec3 l,vec3 v,vec3 n){
      vec3 h = normalize(l+v);
      return vec3(CT_D(l,v,n,h) * CT_F(l,v,n,h) * CT_G(l,v,n,h)/(4.0 * dot(l,n) * dot(v,n)));
    }
  #endif

  #ifndef PBR_BRDF
    #define PBR_BRDF pbrBRDF
    vec3 pbrBRDF(vec3 c,vec3 i,vec3 o,vec3 n){
      float k0 = 0.3;
      return DIFFUSE_BRDF(c,i,o,n) * k0 + SPECULAR_BRDF(i,o,n) * (1.0 - k0);
    }
  #endif
#ifdef USE_DIR_LIGHT
  vec3 directionalLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition){
    vec3 result = vec3(0,0,0);
    for(int i = 0; i < DIR_LIGHT_COUNT;i++){
      vec3 lI = lambert(fragNormal,-_dLightDir[i])* _dLightColor[i];
      vec3 lColor = lI * PBR_BRDF(baseColor,-_dLightDir[i],normalize(_cameraPosition - fragPosition),fragNormal);
      result += lColor;
    }
    return result;
  }
#endif
#ifdef USE_POINT_LIGHT
  vec3 pointLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition){
    vec3 result = vec3(0,0,0);
    for(int i = 0; i < POINT_LIGHT_COUNT;i++){
      vec3 l2p = _pLightPosition[i] - fragPosition;
      float d = length(l2p);
      vec2 param = _pLightParam[i];
      float atten = max(0.,1.0-d/param.x)/(1.0 + param.y*param.y*d);
      l2p = normalize(l2p);
      vec3 lI = lambert(fragNormal,l2p)* _pLightColor[i] * atten;
      vec3 lColor = lI  * PBR_BRDF(baseColor,l2p,normalize(_cameraPosition - fragPosition),fragNormal);
      result += lColor ;
    }
    return result;
  }
#endif
#ifdef USE_SPOT_LIGHT
  vec3 spotLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition){
    vec3 result = vec3(0);
    for(int i = 0; i < SPOT_LIGHT_COUNT; i++){
      float innerConeAngle = _sLightParam[i].x;
      float outerConeAngle = _sLightParam[i].y;
      float outCos=cos(outerConeAngle);
      float innCos=cos(innerConeAngle);

      vec3 p2l = _sLightPosition[i] - fragPosition;
      float d = length(p2l);
      p2l=p2l/d;
      float c = dot(-p2l,normalize(_sLightDir[i]));

      float decay = _sLightParam[i].z;//減衰係数
      decay = 1.;
      float distanceDecay = decay;
      float angleDecay = decay;
      //
      float outerDistance = 10.0;
      float innerDistance = 0.1;
      //
      float distDecayCoefficient = pow(clamp((outerDistance-d)/(outerDistance-innerDistance),0.0,1.0),distanceDecay);
      float angleDecayCoefficient = pow(clamp((c-outCos)/(innCos-outCos),0.0,1.0),angleDecay);
      //
      vec3 lI = lambert(p2l,fragNormal)*_sLightColor[i]*angleDecayCoefficient*distDecayCoefficient;
      vec3 lColor = lI * PBR_BRDF(baseColor,p2l,normalize(_cameraPosition - fragPosition),fragNormal);;
      result += lColor;
    }
    return result;
  }
#endif
  vec3 shading(vec3 baseColor,vec3 fragNormal,vec3 fragPosition){
    vec3 lightingColor = vec3(0);
    #ifdef USE_DIR_LIGHT
    lightingColor.rgb += directionalLight(baseColor,fragNormal,fragPosition);
    #endif
    #ifdef USE_POINT_LIGHT
    lightingColor.rgb += pointLight(baseColor,fragNormal,fragPosition);
    #endif
    #ifdef USE_SPOT_LIGHT
    lightingColor.rgb += spotLight(baseColor,fragNormal,fragPosition);
    #endif
    return lightingColor;
  }
