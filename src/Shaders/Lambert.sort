@Pass

varying vec3 vNormal;
varying vec2 vUV;
varying vec3 vPosition;

@vert{
  attribute vec3 position;
  attribute vec3 normal;
  attribute vec2 uv;

  uniform mat4 _matPVM;
  uniform mat4 _matM;

  void main(){
    gl_Position = _matPVM * vec4(position,1.0);
    vNormal = normalize((_matM * vec4(normal,0.0)).xyz);
    vec4 posBase = (_matM * vec4(position,1.0));
    vPosition = posBase.xyz / posBase.w;
    vUV = uv;
  }
}

@frag{
  uniform vec3 _cameraPosition;
  uniform vec3 _dLightDir[5];
  uniform vec3 _dLightColor[5];
  uniform vec3 _pLightPosition[5];
  uniform vec3 _pLightColor[5];
  uniform vec2 _pLightParam[5];
  uniform vec3 _sLightPosition[5];
  uniform vec3 _sLightDir[5];
  uniform vec3 _sLightColor[5];
  uniform vec3 _sLightParam[5];

  uniform sampler2D texture;

  @{default:"white",type:"color"}
  uniform vec4 diffuse;

  @{default:"gray",type:"color"}
  uniform vec3 specular;

  @{default:1.0}
  uniform float specularPower;

  float lambert(vec3 lightDirection,vec3 surfaceNormal) {
    return max(0.0, dot(lightDirection, surfaceNormal));
  }

  float blinnPhongSp(vec3 lightDirection,vec3 viewDirection,vec3 surfaceNormal,float shininess) {
    vec3 H = normalize(viewDirection + lightDirection);
    return pow(max(0.0, dot(surfaceNormal, H)), shininess);
  }

  vec3 directionalLight(vec3 dBaseColor){
    vec3 result = vec3(0,0,0);
    for(int i = 0; i < 5;i++){
      vec3 lColor = lambert(_dLightDir[i],vNormal) * dBaseColor + blinnPhongSp(_dLightDir[i],normalize(_cameraPosition - vPosition),vNormal,specularPower) * specular;
      result += lColor * _dLightColor[i] ;
    }
    return result;
  }

  vec3 pointLight(vec3 dBaseColor){
    vec3 result = vec3(0,0,0);
    for(int i = 0; i < 5;i++){
      vec3 l2p = _pLightPosition[i] - vPosition;
      float d = length(l2p);
      vec2 param = _pLightParam[i];
      float atten = max(0.,1.0-d/param.x)/(1.0 + param.y*param.y*d);
      l2p = normalize(l2p);
      vec3 lColor = lambert(l2p,vNormal) * dBaseColor + blinnPhongSp(l2p,normalize(_cameraPosition - vPosition),vNormal,specularPower) * specular;
      result += lColor * _pLightColor[i] * atten ;
    }
    return result;
  }

  vec3 spotLight(vec3 dBaseColor){
    vec3 result = vec3(0);
    for(int i = 0; i < 5; i++){
      float innerConeAngle = _sLightParam[i].x;
      float outerConeAngle = _sLightParam[i].y;
      float outCos=cos(outerConeAngle);
      float innCos=cos(innerConeAngle);

      vec3 l2p = vPosition-_sLightPosition[i];
      float d = length(l2p);
      l2p=l2p/d;
      float c = dot(l2p,normalize(_sLightDir[i]));

      float decay = _sLightParam[i].z;//減衰係数
      decay = 1.;
      float distanceDecay = decay;
      float angleDecay = decay;
      //
      float outerDistance = 10.0;
      float innerDistance = 0.1;
      //
      float distDecayCoefficient = pow(clamp((outerDistance-d)/(outerDistance-innerDistance),0.0,1.0),distanceDecay);
      float angleDecayCoefficient = pow(clamp((c-outCos)/(innCos-outCos),0.0,1.0),angleDecay);
      //
      vec3 lColor = lambert(-1.0*l2p,vNormal) * dBaseColor + blinnPhongSp(l2p,normalize(_cameraPosition - vPosition),vNormal,specularPower) * specular;
      result += lColor*_sLightColor[i]*angleDecayCoefficient*distDecayCoefficient;
    }
    return result;
  }

  void main(){
    vec4 lastColor = vec4(0,0,0,diffuse.a);
    vec3 dColor = diffuse.rgb * texture2D(texture,vUV).rgb;
    lastColor.rgb += directionalLight(dColor);
    lastColor.rgb += pointLight(dColor);
    lastColor.rgb += spotLight(dColor);
    gl_FragColor = lastColor;
  }
}
